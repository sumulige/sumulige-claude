/**
 * Sync Commands Module
 *
 * Extracted from lib/commands.js (lines 336-607)
 * Contains: sync, migrate commands
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const { loadConfig, ensureDir } = require("../config");
const { copyRecursive } = require("../utils");
const { runMigrations, TEMPLATE_VERSION } = require("../migrations");
const { checkUpdate } = require("../version-check");
const syncPlan = require("../sync-plan");

const TEMPLATE_DIR = path.join(__dirname, "../../template");

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Set executable permission for script files
 * @param {string} filePath - File path
 */
function setExecutablePermission(filePath) {
  if (filePath.endsWith(".sh") || filePath.endsWith(".cjs")) {
    try {
      fs.chmodSync(filePath, 0o755);
    } catch (e) {
      // Ignore permission errors
    }
  }
}

/**
 * Generate AGENTS.md content from config
 * @param {Object} config - Configuration object
 * @returns {string} AGENTS.md content
 */
function generateAgentsMd(config) {
  const agents = config.agents || {};
  let content = `# AGENTS.md - Agent Routing Configuration

> Auto-generated by Sumulige Claude. Do not edit directly.
> Edit config via: smc config

## Active Agents

`;

  for (const [name, agent] of Object.entries(agents)) {
    content += `### ${name}\n`;
    content += `- **Description**: ${agent.description || "No description"}\n`;
    content += `- **Trigger**: ${agent.trigger || "manual"}\n`;
    if (agent.model) {
      content += `- **Model**: ${agent.model}\n`;
    }
    content += "\n";
  }

  return content;
}

// ============================================================================
// Commands
// ============================================================================

const commands = {
  "sync:plan": async (...args) => {
    console.log("üìù Plan: sync template ‚Üí .claude/upstream (non-destructive)");
    const projectDir = process.cwd();
    const planResult = syncPlan.plan(projectDir);
    const json = args.includes("--json");
    if (json) {
      console.log(JSON.stringify(syncPlan.toJSON(planResult), null, 2));
    } else {
      syncPlan.printPlan(planResult);
      console.log("\n‚ÑπÔ∏è  No files were modified. Run: smc sync:apply");
    }
  },

  "sync:apply": async () => {
    console.log("üîÑ Applying plan to .claude/upstream ...");
    const projectDir = process.cwd();
    const planResult = syncPlan.plan(projectDir);
    const applied = syncPlan.applyPlan(planResult);
    syncPlan.printPlan({ results: applied });
    console.log("\n‚úÖ Applied to .claude/upstream (local/custom not touched).");
  },

  sync: async (...args) => {
    const forceCheckUpdate = args.includes("--check-update");
    const syncHooks = args.includes("--hooks");
    const incrementalSync = args.includes("--incremental");
    const forceSync = args.includes("--force");

    // Incremental sync mode
    if (incrementalSync) {
      console.log("üîÑ Running incremental sync...");
      console.log("");

      const projectDir = process.cwd();
      const incrementalLib = require("../incremental-sync");
      const result = incrementalLib.incrementalSync(projectDir, { force: forceSync });

      if (result.needsFullSync) {
        console.log("‚ÑπÔ∏è  " + result.message);
        console.log("   Run: smc sync (without --incremental)");
        return;
      }

      if (result.hasBreakingChanges) {
        console.log("‚ö†Ô∏è  " + result.message);
        console.log("");
        result.changes.forEach((c) => {
          if (c.breaking) {
            console.log(`   üî¥ v${c.version}: Breaking changes`);
          }
        });
        return;
      }

      if (!result.success) {
        console.log("‚ùå " + result.message);
        return;
      }

      console.log(`‚úÖ ${result.message}`);
      if (result.results) {
        const applied = result.results.filter((r) => r.result.success && !r.result.skipped);
        applied.forEach((r) => {
          console.log(`   ‚úÖ [${r.version}] ${r.change.type}: ${r.change.name || r.change.feature}`);
        });
      }
      console.log("");
      console.log("‚úÖ Incremental sync complete!");
      return;
    }

    console.log("üîÑ Syncing Sumulige Claude to current project...");
    console.log("");

    const projectDir = process.cwd();
    const projectConfigDir = path.join(projectDir, ".claude");
    const agentsFile = path.join(projectConfigDir, "AGENTS.md");
    const readmeFile = path.join(projectConfigDir, "README.md");
    const templateReadme = path.join(TEMPLATE_DIR, ".claude", "README.md");

    // Create .claude directory
    ensureDir(projectConfigDir);

    // Run migrations (version-aware)
    const result = runMigrations(projectDir);
    if (result.migrations.length > 0) {
      console.log(`üì¶ Migrating project template ‚Üí v${TEMPLATE_VERSION}`);
      result.migrations.forEach((m) => {
        console.log(`   ‚úÖ ${m.description}`);
      });
      console.log("");
    }

    console.log("‚úÖ Created .claude directory");

    // Sync config
    const config = loadConfig();

    // Generate AGENTS.md
    const agentsMd = generateAgentsMd(config);
    fs.writeFileSync(agentsFile, agentsMd);
    console.log("‚úÖ Created AGENTS.md");

    // Silently sync README.md if template updated
    if (fs.existsSync(templateReadme)) {
      const templateContent = fs.readFileSync(templateReadme, "utf-8");
      let needsUpdate = true;

      if (fs.existsSync(readmeFile)) {
        const existingContent = fs.readFileSync(readmeFile, "utf-8");
        const templateVersion =
          templateContent.match(/@version:\s*(\d+\.\d+\.\d+)/)?.[1] || "0.0.0";
        const existingVersion =
          existingContent.match(/@version:\s*(\d+\.\d+\.\d+)/)?.[1] || "0.0.0";
        needsUpdate = templateVersion !== existingVersion;
      }

      if (needsUpdate) {
        fs.writeFileSync(readmeFile, templateContent);
      }
    }

    // Sync hooks if --hooks flag is provided
    if (syncHooks) {
      const templateHooksDir = path.join(TEMPLATE_DIR, ".claude", "hooks");
      const projectHooksDir = path.join(projectConfigDir, "hooks");
      const templateSettingsFile = path.join(
        TEMPLATE_DIR,
        ".claude",
        "settings.json",
      );
      const projectSettingsFile = path.join(projectConfigDir, "settings.json");

      if (fs.existsSync(templateHooksDir)) {
        ensureDir(projectHooksDir);

        // Sync hook files (only add new ones, don't overwrite)
        const hookFiles = fs
          .readdirSync(templateHooksDir)
          .filter((f) => f.endsWith(".cjs"));
        let syncedCount = 0;

        hookFiles.forEach((hookFile) => {
          const src = path.join(templateHooksDir, hookFile);
          const dest = path.join(projectHooksDir, hookFile);

          if (!fs.existsSync(dest)) {
            fs.copyFileSync(src, dest);
            setExecutablePermission(dest);
            syncedCount++;
            console.log(`   ‚úÖ Added ${hookFile}`);
          }
        });

        if (syncedCount > 0) {
          console.log(`‚úÖ Synced ${syncedCount} new hook(s)`);
        } else {
          console.log("‚úÖ Hooks up to date");
        }
      }

      // Sync settings.json (merge new lifecycle hooks)
      if (
        fs.existsSync(templateSettingsFile) &&
        fs.existsSync(projectSettingsFile)
      ) {
        try {
          const templateSettings = JSON.parse(
            fs.readFileSync(templateSettingsFile, "utf-8"),
          );
          const projectSettings = JSON.parse(
            fs.readFileSync(projectSettingsFile, "utf-8"),
          );

          // Merge new lifecycle hooks
          const lifecycleHooks = [
            "SessionStart",
            "SessionEnd",
            "PreCompact",
            "env",
          ];
          let updated = false;

          lifecycleHooks.forEach((hook) => {
            if (templateSettings[hook] && !projectSettings[hook]) {
              projectSettings[hook] = templateSettings[hook];
              updated = true;
              console.log(`   ‚úÖ Added ${hook} hook`);
            }
          });

          if (updated) {
            fs.writeFileSync(
              projectSettingsFile,
              JSON.stringify(projectSettings, null, 2),
            );
            console.log("‚úÖ Updated settings.json");
          }
        } catch (e) {
          console.log("‚ö†Ô∏è  Failed to merge settings.json");
        }
      }
    }

    // Sync todos directory structure
    const todosTemplateDir = path.join(TEMPLATE_DIR, "development", "todos");
    const todosProjectDir = path.join(projectDir, "development", "todos");

    if (fs.existsSync(todosTemplateDir)) {
      copyRecursive(todosTemplateDir, todosProjectDir);
    }

    // Sync skills
    try {
      execSync("openskills sync -y", { stdio: "pipe" });
      console.log("‚úÖ Synced skills");
    } catch (e) {
      console.log("‚ö†Ô∏è  Failed to sync skills");
    }

    // Update project version after full sync
    try {
      const versionManifest = require("../version-manifest");
      const currentVersion = versionManifest.getCurrentVersion();
      if (currentVersion) {
        versionManifest.setProjectVersion(projectDir, currentVersion);
      }
    } catch (e) {
      // Version manifest not available, ignore
    }

    console.log("");
    console.log("‚úÖ Sync complete!");

    // Check for updates (sync is already a network operation)
    await checkUpdate({ force: forceCheckUpdate, silent: false });
  },

  migrate: () => {
    console.log("üîß Migrating project to latest format...");
    console.log("");

    const projectDir = process.cwd();
    const settingsFile = path.join(projectDir, ".claude", "settings.json");

    if (!fs.existsSync(settingsFile)) {
      console.log("‚ö†Ô∏è  No settings.json found in .claude/");
      console.log("   Run: smc template");
      return;
    }

    let settings;
    try {
      settings = JSON.parse(fs.readFileSync(settingsFile, "utf-8"));
    } catch (e) {
      console.log("‚ùå Invalid JSON in settings.json");
      return;
    }

    // Detect old format
    const isOldFormat =
      settings.matcher ||
      (settings.hooks && typeof settings.hooks === "object");

    if (!isOldFormat) {
      console.log("‚úÖ Already using latest format");
      return;
    }

    // Read new template
    const templateSettings = path.join(
      TEMPLATE_DIR,
      ".claude",
      "settings.json",
    );
    if (!fs.existsSync(templateSettings)) {
      console.log("‚ùå Template settings.json not found");
      return;
    }

    const newSettings = fs.readFileSync(templateSettings, "utf-8");
    fs.writeFileSync(settingsFile, newSettings);

    console.log("‚úÖ Migrated settings.json to latest format");
    console.log("");
    console.log("Changes:");
    console.log('  - Old format: {"matcher": "...", "hooks": [...]}');
    console.log(
      '  - New format: {"UserPromptSubmit": [...], "PostToolUse": [...]}',
    );
    console.log("");
    console.log("‚ÑπÔ∏è  Hooks will now work correctly!");
  },
};

module.exports = commands;
